/* BootX * * Written by Benjamin Herrenschmidt * * portions of this code from InfiniteOS boot loader by <...>, portions from * quik by Paul Mackerras. * * GPL.... * * This file contains all the code involved in loading kernels, ramdisks, * preparing the boot environement and doing the actual boot. * It's shared between BootX and miBoot * * NOTES: - The enclosing module must export a "dct" variable containing the *          dt_context used for debugging. *        - This modules uses the NameRegistry API when running on a PCI machine. *          If compiling 68k code, you need to provide the NR API via the wrappers *          in the same link unit. *        - We do pass FSSpecs, but we never use FSpXXXX functions in case they are *          not in ROM. *        - This version still uses Gestalt which can cause trouble with older ROMs. *			We should check before using. Will NuBus PPC ROMs support it ? This may *          be an issue for 68k only (but most of this code should work with 68k macs) * * * This module requires BOOTX_ENV to be defined to one of those: *    BOOTX_ENV_APPLICATION		Application version, uses files and system heap *    BOOTX_ENV_EXTENSION		Extension version, uses files and bufptr memory *    BOOTX_ENV_RAW				Boot block version, uses block/io and bufptr memory * * Both file desc structure use either a FSSpec/fileRefNum (application and extension) * or a block map with a driver refNum (boot blocks). There's currently no way to use * "raw" SCSK or ATA without a driver. In the boot block version, open and close are * skipped and the block map is expected to be provided by the caller. * The block map format is a semi-compressed map formed of pairs of long words: * [block_number][block_count] [block_number][block_count] ... * The end of the map is marked by a (0,0) entry. * * The bootblock version must be linked with a couple more globals: *   Ptr	g_low_68k_strap			pointer to low-level 68k bootstrap entry *	 Ptr	g_low_PPC_pre_strap		pointer to low-level PPC bootstrap entry *   Ptr	g_low_PPC_strap			pointer to low-level PPC boostrap * */ #ifndef __BOOTX_BOOT_H__#define __BOOTX_BOOT_H__#include "bootx.h"#ifndef BOOTX_ENV#error BOOTX_ENV not defined !#endif#define	BOOTX_ENV_APPLICATION	0#define	BOOTX_ENV_EXTENSION		1#define	BOOTX_ENV_RAW			2//#define BOOTX_USES_FILES		(BOOTX_ENV != BOOTX_ENV_RAW)#define BOOTX_USES_FILES		1#define BOOTX_USES_BUFPTR		(BOOTX_ENV != BOOTX_ENV_APPLICATION)/* This option reverts to old bootx behaviour:   the kernel is entered directly, without turnig OFF the MMU. */#ifndef NO_BOOTSTRAP#define NO_BOOTSTRAP			0#endif//#if BOOTX_ENV == BOOTX_ENV_RAW//extern Ptr	g_low_68k_strap;		// pointer to low-level 68k bootstrap entry//extern Ptr	g_low_PPC_pre_strap;	// pointer to low-level PPC bootstrap entry//extern Ptr	g_low_PPC_strap;		// pointer to low-level PPC boostrap//#endif/* This is a pseudo-file struture */typedef struct boot_file {#if BOOTX_USES_FILES	FSSpec		spec;	/* MacOS FSSpec */#else	UInt32*		map;	/* Block map (number-count) */#endif		short		rn;		/* MacOS refNum or -1 */		UInt32		size;	/* File size */	StringPtr	name;	/* Pointer to name */	} boot_file_t;/* This structure describes a kernel file, with all informations   required by the boot code about it. */typedef struct boot_kernel_desc {	boot_file_t*	file;	UInt32			offset;		/* Offset of kernel image in file */	UInt32			size;		/* Size of kernel image in file */	UInt32			mem_size;	/* Memory footprint of the kernel */	UInt32			entry;		/* Relative entry point  */	UInt32			load_base;	/* Kernel expected load base */	Boolean			zImage;		/* File is gzipped XCOFF */} boot_kernel_desc_t;/* This structure describes a ramdisk file. This can be the same file   as the kernel file. */typedef struct boot_ramdisk_desc {	boot_file_t*	file;	UInt32			offset;		/* Offset of the ramdisk image in the file */	UInt32			size;		/* Size of the ramdisk image in the file */} boot_ramdisk_desc_t;/* This structure contains various parameters passed to do_boot */typedef struct boot_params {	char*			args;			/* Kernel args (command line) */	Boolean			setup_video;	Boolean			force_scsi;	Boolean			close_video;	Boolean			override_l2cr;	UInt32			l2cr_value;	Boolean			no_relocation;	Boolean			reset_ata;} boot_params_t;/* Checks a file supposed to be a kernel. This function will open the file,   try to guess it's format, fill out the passed in structures according to   the file content and return wether this file was a valid kernel or not.   Note that only some fields are filled in the scructure. do_boot() will   take care of the remaining fields. */Boolean	check_kernel_file(	boot_file_t 		*in_file,							boot_kernel_desc_t	*out_kernel_infos,							boot_ramdisk_desc_t	*out_ramdisk_infos,							Boolean				*out_has_ramdisk);/* Checks a ramdisk file. The current implementation returns true all   the time if the file exists and fills out the boot_ramdisk_desc_t with   infos about the entire file data fork without opening it. */Boolean check_ramdisk_file(	boot_file_t			*in_file,							boot_ramdisk_desc_t	*out_ramdisk_infos);							/* This function does the actual boot of the kernel, prepares all data   structurees and boot. Note that only the application version will return   from this function when successfull. In this case, the application is   expected to quit as soon as possible. Files will have been closed. */enum boot_kind {	boot_miBoot,	boot_extension,	boot_application};OSStatus do_boot(			boot_kernel_desc_t	*in_kernel_infos,							boot_ramdisk_desc_t	*in_ramdisk_infos,							boot_params_t		*in_params);#endif