/* This code fragments provides the low-level 68k boot code   with some PPC functions (necessary for using the name   registry API for example). */ #include <PCI.h>#include <Errors.h>#include <MixedMode.h>#include <CodeFragments.h>#include <Gestalt.h>#include <NameRegistry.h>#include <ROMDefs.h>#include <Devices.h>#include <Slots.h>#include "BootX.h"#include "LowLevelBoot.h"#include "debug_text.h"#include "uLibc.h"#define DEBUG	1#ifndef BROKEN_THIRD_PARTY_CARDS#define BROKEN_THIRD_PARTY_CARDS	1#endif#define MAX_STRING_PROP_SIZE	256#define MAX_ASSIGNED_ADDRESSES	8#define IDE_BUSY_STAT	0x80#define	kPCIConfigCommandAddress		0x04		/* PCI "Command" config register address	*/#define		cwCommandEnableMemorySpace	0x0002		/*   enable memory space bit */#define		cwCommandEnableIOSpace		0x0001		/*   enable i/o space bit */#define kAAPLDeviceLogicalAddress	"AAPL,address"/* Exported */extern pascal void* main(void);extern pascal void ShutDownDevices(dt_context *in_dct, boot_infos_t* bi);UInt32 __procinfo = kPascalStackBased | RESULT_SIZE(SIZE_CODE(sizeof(void*)));typedef void (*iterate_device_proc)(RegEntryIDPtr entryID);static OSStatus	iterate_devices(iterate_device_proc	proc);static SInt32	read_pci_config_reg(RegEntryIDPtr entryID, int reg);static UInt32	get_assigned_addresses(RegEntryIDPtr entryID, PCIAssignedAddress* outAddresses);static void		get_string_property(RegEntryIDPtr entryID, char* prop_name, char *out_string);static UInt32	get_io_addresses(RegEntryIDPtr entryID, UInt32 *out_addresses);static Boolean	check_vendor_device_id(RegEntryIDPtr entryID, UInt16 vendorID, UInt16 deviceID);static OSStatus	get_one_property(	RegEntryIDPtr			regEntryIDPtr,									RegPropertyNamePtr		regPropertyName,									void					*regPropertyValuePtr,									UInt32					*regPropertyValueSizePtr);static OSStatus	find_child_device(RegEntryIDPtr parent, RegEntryIDPtr result);static void		reset_apple_SCSI_UW_board(RegEntryIDPtr entryID);static void		reset_apple_DBDMA_channels(RegEntryIDPtr entryID);static void		reset_apple_USB(RegEntryIDPtr entryID);static void		reset_ATI_mach64_master(RegEntryIDPtr entryID);static void		reset_ATI_rage128_master(RegEntryIDPtr entryID);static void		reset_IDE_disks(RegEntryIDPtr entryID);static void		remap_PDM_video(void);static Boolean	is_internal_PDM_video();static dt_context *dct;/* Placeholders */static PCIAssignedAddress	g_assigned_addresses[16];static LogicalAddress		g_logical_addresses[16];RoutineDescriptor	g_desc = BUILD_ROUTINE_DESCRIPTOR(uppLowLevelBootPPCProcInfo, ShutDownDevices);pascal void*main(void){	return &g_desc;}pascal voidShutDownDevices(dt_context *in_dct, boot_infos_t* bi){	dct = in_dct;#define VIDEO_RAM_SIZE 0x100000			dt_printf(dct, "Shutting down devices...\n");		/* NuBus: Change address of PDM framebuffer */	if ((long)RegistryEntryIDInit == kUnresolvedCFragSymbolAddress) {		dt_printf(dct, "No name registry !\n");		if (bi->architecture & BOOT_ARCH_NUBUS_PDM) {			Boolean PDM_video_screen;			UInt32 i;						PDM_video_screen = is_internal_PDM_video();			dt_printf(dct, "remapping internal PDM video...");			if (PDM_video_screen) {				UInt32 j;								bi->logicalDisplayBase = (UInt8*)0x100000;				bi->dispDeviceBase = (UInt8*)0x100000;				if (dct->visible) {					dt_printf(dct, "waiting a little bit so you can read all that stuff ...\n");					for(j=0;j<0x8000000; j++)						(void)*((volatile char *)(0));					dct->base = (unsigned char *) 0x100000;				}			}			remap_PDM_video();			dt_printf(dct, "Internal PDM video remapped.\n");				for(i=0; i<bi->physMemoryMapSize; i++) {					if ((bi->physMemoryMap[i].physAddr <= (UInt32)bi->dispDeviceBase) &&						((bi->physMemoryMap[i].physAddr + bi->physMemoryMap[i].size)							> (UInt32)bi->dispDeviceBase)) {						UInt32 count = bi->physMemoryMapSize;						UInt32 size = bi->physMemoryMap[i].size;						memmove(&bi->physMemoryMap[i+1], &bi->physMemoryMap[i],							sizeof(boot_info_map_entry_t) * (count-i-1));						bi->physMemoryMap[i].size = (UInt32)bi->dispDeviceBase - bi->physMemoryMap[i].physAddr;					bi->physMemoryMap[i+1].physAddr = (UInt32)bi->dispDeviceBase + VIDEO_RAM_SIZE;					bi->physMemoryMap[i+1].size = (size + bi->physMemoryMap[i].physAddr - bi->physMemoryMap[i+1].physAddr) + VIDEO_RAM_SIZE;						bi->physMemoryMapSize++;						break;					}				}				}	} else {		/* PCI: Disable DMA on known devices */		iterate_devices(reset_apple_SCSI_UW_board);		iterate_devices(reset_apple_DBDMA_channels);		iterate_devices(reset_apple_USB);		iterate_devices(reset_ATI_mach64_master);		iterate_devices(reset_ATI_rage128_master);		iterate_devices(reset_IDE_disks);	}}#if BROKEN_THIRD_PARTY_CARDSstatic asm fixed_eieio(void) {	li r0,0;	cmpwi r0,0;	bne+ toto;	eieio;	toto:;}#else#define fixed_eieio()	__eieio()#endif/* Return true, if the main monitor is connected to the internal PDM video card.*/static Boolean is_internal_PDM_video(void){	GDHandle 		device;	AuxDCEHandle	DCEHand;	SpBlock			mySpBlk;	OSErr			err;	struct SPRAMRecord {		/* It seems that this definition is missing in CW 5 */		short	BoardID;		char	vendorUse1;		char	vendorUse2;		char	vendorUse3;		char	vendorUse4;		char	vendorUse5;		char	vendorUse6;	} pram;		device = GetMainDevice();	if (!device)		return(false);	DCEHand = (AuxDCEHandle) GetDCtlEntry((**device).gdRefNum);	if (!DCEHand)		return(false);	mySpBlk.spParamData = fall;	mySpBlk.spCategory = catDisplay;	mySpBlk.spCType = typeVideo;	mySpBlk.spDrvrSW = 0;	mySpBlk.spDrvrHW = 0;	mySpBlk.spTBMask = 3;	mySpBlk.spSlot = (**DCEHand).dCtlSlot;	mySpBlk.spID = 1;	mySpBlk.spExtDev = 0;	mySpBlk.spResult = (long) &pram;	err = SReadPRAMRec(&mySpBlk);	if (err != noErr)		return(false);	return(pram.BoardID == PDMBrdID);}static voidremap_PDM_video(void){	unsigned char savevalue[35];	int i;		*((volatile unsigned char *)0x50F40008) = 0;	/* reset bit counter */	fixed_eieio();	for (i=0; i<35; i++) {		savevalue[i] = *((volatile unsigned char *)0x50F40000);		fixed_eieio();	}	savevalue[33] = 0;	/* change Video Base to 1Mb */	*((volatile unsigned char *)0x50F40008) = 0;	/* reset bit counter again */	fixed_eieio();	for (i=0; i<35; i++) {		*((volatile unsigned char *)0x50F40000) = savevalue[i];		fixed_eieio();	}}static voidget_string_property(RegEntryIDPtr entryID, char* prop_name, char *out_string){	OSStatus				err;	RegPropertyValueSize	size;			size = MAX_STRING_PROP_SIZE-1;		err = RegistryPropertyGet(entryID, prop_name, out_string, &size);	if (err == noErr)		out_string[size] = 0;	else		out_string[0] = 0;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * This is a generic function that retrieves a property from the Name Registry, * allocating memory for it in the system pool. It looks in the Name Registry entry * for this driver -- the DriverInitializeCmd passed this as one of its parameters. * This sample is specific to device drivers: it allocates the property in the resident * memory pool. */OSStatusget_one_property(		RegEntryIDPtr			regEntryIDPtr,			/* Driver's Name Registery ID	*/		RegPropertyNamePtr		regPropertyName,		void					*regPropertyValuePtr,		UInt32					*regPropertyValueSizePtr	){		OSStatus				status;		/*		 * In addition to getting the size of a property, this function will fail if		 * the property is not present in the registry. We NULL the result before		 * starting so we can dispose of the property even if this function failed.		 */		status = RegistryPropertyGetSize(					regEntryIDPtr,					regPropertyName,					regPropertyValueSizePtr				);		if (status == noErr) {			status = RegistryPropertyGet(						regEntryIDPtr,						regPropertyName,						regPropertyValuePtr,						regPropertyValueSizePtr					);			if (status != noErr)				dt_printf(dct, "RegistryPropertyGet failed (err:%d)\n", status);		}		return (status);}static UInt32count_assigned_addresses(RegEntryIDPtr entryID){	OSStatus				err;	RegPropertyValueSize	size;	size = MAX_ASSIGNED_ADDRESSES * sizeof(PCIAssignedAddress);	err = RegistryPropertyGet(entryID, kPCIAssignedAddressProperty, g_assigned_addresses, &size);	if (err == noErr)		return size/sizeof(PCIAssignedAddress);	else		return 0;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * GetDeviceLogicalAddress * * Retrieve the assigned-address property from the Name Registry and search it for * the specified addressSpaceSelector. This function uses the device base register * only: it ignores the I/O vs. Memory space selector. It will need modification if * the hardware supports 64-bit addressing or needs to understand address spaces. */OSStatusget_logical_address(		RegEntryIDPtr			regEntryIDPtr,			/* Driver's Name Registery ID	*/		PCIRegisterNumber		deviceRegister,			/* Register in address property	*/		LogicalAddress			*deviceLogicalAddress,	/* Gets the logical address		*/		ByteCount				*deviceAreaLength		/* Gets the area size			*/	){		OSStatus				status;		UInt32					i;						/* Vector index					*/		UInt32					nAddresses;				/* Number of vector elements	*/		RegPropertyValueSize	assignedAddressSize;		RegPropertyValueSize	logicalAddressSize;		PCIAssignedAddressPtr	pciAssignedAddressPtr;	/* Assigned Address element ptr	*/		StringPtr				failureMsg;				failureMsg				= NULL;				status = noErr;		if (deviceLogicalAddress == NULL)			return paramErr;		if (deviceRegister != 0) {			/*			 * Fetch the assigned address and AAPL,address properties. Allocate memory			 * for each. Note that if deviceRegister is 0, we skip this and use the			 * first entry in the AAPL,address property			 */			status = get_one_property(						regEntryIDPtr,						kPCIAssignedAddressProperty,						(RegPropertyValue*)g_assigned_addresses,						&assignedAddressSize);			if (status != noErr) {				dt_printf(dct, "No assigned-addresses property (err: %d)\n", status);				return status;			}		}		status = get_one_property(					regEntryIDPtr,					kAAPLDeviceLogicalAddress,					(RegPropertyValue*)g_logical_addresses,					&logicalAddressSize);		if (status != noErr) {			dt_printf(dct, "No AAPL,address property (err: %d)\n", status);			return status;		}				if (deviceRegister == 0) {			*deviceLogicalAddress = g_logical_addresses[0];			if (deviceAreaLength)				*deviceAreaLength = 0;			return noErr;		}		status					= paramErr;		nAddresses				= assignedAddressSize / sizeof (PCIAssignedAddress);		pciAssignedAddressPtr	= (PCIAssignedAddressPtr) g_assigned_addresses;					for (i = 0; i < nAddresses; i++, pciAssignedAddressPtr++) {			if (GetPCIRegisterNumber(pciAssignedAddressPtr) == deviceRegister) {				if (pciAssignedAddressPtr->size.hi != 0			/* 64-bit area?		*/				 || pciAssignedAddressPtr->size.lo == 0)			{												/* Zero length		*/				/*				 * Open Firmware was unable to assign a valid address to this				 * memory area. We must return an error to prevent the driver				 * from starting up. Is there a better error status?				 */				status = paramErr;			}			else if (i >= (logicalAddressSize / sizeof (LogicalAddress))) {				/*				 * The logical address vector is too small -- this is a bug.				 */				status = paramErr;			}			else {				status = noErr;				*deviceLogicalAddress = g_logical_addresses[i];				if (deviceAreaLength)					*deviceAreaLength = pciAssignedAddressPtr->size.lo;			}			break; /* Exit loop when we find the desired register */				}		}		if (status != noErr)			dt_printf(dct, "No valid address space (err: %d)\n", status);		return (status);}static Booleancheck_vendor_device_id(RegEntryIDPtr entryID, UInt16 vendorID, UInt16 deviceID){	UInt32		pSize;	OSStatus	err;	UInt16		prop;		pSize = 2;	err = RegistryPropertyGet(entryID, "vendor-id", &prop, &pSize);	if ((err != noErr)||(pSize != 2))		return false;	if (prop != vendorID)		return false;	pSize = 2;	err = RegistryPropertyGet(entryID, "device-id", &prop, &pSize);	if ((err != noErr)||(pSize != 2))		return false;	return (prop == deviceID);}static SInt32read_pci_config_reg(RegEntryIDPtr entryID, int reg){	OSStatus	status;	UInt16		value;		status = ExpMgrConfigReadWord(entryID, (LogicalAddress)reg, &value);	if (status != noErr)		return -1;	return value;}voidreset_apple_DBDMA_channels(RegEntryIDPtr entryID){	char				prop[MAX_STRING_PROP_SIZE];	UInt32				addrs_count;	volatile UInt32		*io_base;		get_string_property(entryID, "device_type", prop);	if (strcmp(prop, "dbdma") && strcmp(prop, "mac-io"))		return;			dt_printf(dct, "dbdma: ");	addrs_count = count_assigned_addresses(entryID);	if (addrs_count < 1) {		dt_printf(dct, "no addresses !\n");		return;	}	if (get_logical_address(entryID, 16, (LogicalAddress *)&io_base, NULL) != noErr) {		dt_printf(dct, "can't get addresses !\n");		return;	}		if (io_base) {		int i;		io_base += 0x2000;	/* base of DBDMA channels */#if DEBUG		dt_printf(dct, "io_base = 0x%x ", io_base);#endif				for (i=0;i<16;i++) {			*(io_base) = 0x000000FCUL;			__eieio();			while((*(io_base+1)) & 0x00800000UL)				__eieio();		}	}	else		dt_printf(dct, "no io_base !\n");	dt_printf(dct, "reseted.\n");}/* Horrible kludge to work around an issue with MacOS 9 IDE drivers */static voidwait_ide_ready(volatile unsigned char* io_status){	int i,j;		for (j = 0; j < 1000; j++) {		unsigned int ide_status;		dt_printf(dct, ".");		for(i=0;i<0x200000;i++)			__eieio();		ide_status = *(io_status); __eieio();		if (!(ide_status & IDE_BUSY_STAT))			break;	}}voidreset_IDE_disks(RegEntryIDPtr entryID){	char					name[MAX_STRING_PROP_SIZE];	char					type[MAX_STRING_PROP_SIZE];	RegEntryIter			iter;	Boolean					found;	Boolean					done;	RegEntryID				parentEntry;	RegPropertyValueSize	logicalAddressSize;	OSStatus				status;	volatile unsigned char*	io_status;	volatile unsigned char*	io_ctl;	unsigned char			ctl_value;	int						i;	RegEntryID				child;	get_string_property(entryID, "name", name);	get_string_property(entryID, "device_type", type);		if (!strcmp(name, "pci-ata") && !strcmp(type, "pci-ide")) {		status = RegistryEntryIDInit(&child);		if (status != noErr)			return;		status = find_child_device(entryID, &child);		if (status != noErr) {			RegistryEntryIDDispose(&child);			return;		}		get_string_property(&child, "name", name);		RegistryEntryIDDispose(&child);		if (strncmp(name, "atapi", 5) == 0)			return;		dt_printf(dct, "pci-ide : ");		status = get_one_property(entryID, kAAPLDeviceLogicalAddress,						(RegPropertyValue*)g_logical_addresses,						&logicalAddressSize);		if (status != noErr) {			dt_printf(dct, "No AAPL,address property (err: %d)\n", status);			return;		}		io_status = (volatile unsigned char *)(((UInt32)g_logical_addresses[0]) + 0x7);		io_ctl = (volatile unsigned char *)(((UInt32)(g_logical_addresses[1]) & 0xFFFFFFFC) + 2);		ctl_value = 0;			} else {		if (strcmp(name, "ATA") && strcmp(name, "IDE") && strcmp(type, "ide")			&& strcmp(type, "ata"))			return;			status = RegistryEntryIDInit(&child);		if (status != noErr)			return;		status = find_child_device(entryID, &child);		if (status != noErr) {			RegistryEntryIDDispose(&child);			return;		}		get_string_property(&child, "name", name);		RegistryEntryIDDispose(&child);		if (strncmp(name, "atapi", 5) == 0)			return;		get_string_property(entryID, "name", name);		dt_printf(dct, "ide <%s> : ", name);		RegistryEntryIterateCreate(&iter);		found = false;		done = false;		RegistryEntryIterateSet(&iter, entryID);		RegistryEntryIDInit(&parentEntry);		status = RegistryEntryIterate(&iter, kRegIterParents, &parentEntry, &done);		while(status == noErr && !done) {			get_string_property(&parentEntry, "device_type", type);			if (strcmp(type, "mac-io") == 0 || strcmp(type, "dbdma") == 0) {				found = true;				break;			}			status = RegistryEntryIterate(&iter, kRegIterContinue, &parentEntry, &done);		} 		RegistryEntryIDDispose(&parentEntry);		RegistryEntryIterateDispose(&iter);		if (!found) {			dt_printf(dct, "No mac-io/dbdma parent !\n");			return;		}			status = get_one_property(entryID, kAAPLDeviceLogicalAddress,						(RegPropertyValue*)g_logical_addresses,						&logicalAddressSize);		if (status != noErr) {			dt_printf(dct, "No AAPL,address property (err: %d)\n", status);			return;		}		io_status = (volatile unsigned char *)(((UInt32)g_logical_addresses[0]) + 0x70);		io_ctl = (volatile unsigned char *)(((UInt32)g_logical_addresses[0]) + 0x160);		ctl_value = 0x8;	}		dt_printf(dct, "0x%08lx/0x%08lx, resetting", io_ctl, io_status);	wait_ide_ready(io_status);	*(io_ctl) = 0x06 | ctl_value; __eieio();	(void)*(io_status); __eieio();	for(i=0;i<0x20000;i++)		__eieio();	*(io_ctl) = 0x02 | ctl_value; __eieio();	for(i=0;i<0x200000;i++)		__eieio();	(void)*(io_status); __eieio();	wait_ide_ready(io_status);	dt_printf(dct, " done.\n");}voidreset_apple_SCSI_UW_board(RegEntryIDPtr entryID){	char				prop[MAX_STRING_PROP_SIZE];	Boolean				found = false;	Boolean				use_io = false;	volatile char*		io_base;	SInt32				cmd;	UInt32				addrs_count;		get_string_property(entryID, "name", prop);	found = (strcmp(prop, "Apple53C875Card") == 0);	if (!found)		found = check_vendor_device_id(entryID, 0x1000, 0xf);	if (!found) {		return;	}	dt_printf(dct, "symbios: ");		cmd = read_pci_config_reg(entryID, kPCIConfigCommandAddress);	use_io = (cmd > 0) && (cmd & cwCommandEnableIOSpace);#if DEBUG	dt_printf(dct, "%s", use_io ? "(io) " : "(mem) ");#endif		addrs_count = count_assigned_addresses(entryID);	if (addrs_count < 2) {		dt_printf(dct, "not enough addresses !\n");		return;	}			if (use_io) {		if (get_logical_address(entryID, 16, (LogicalAddress *)&io_base, NULL) != noErr) {			dt_printf(dct, "symbios: can't get addresses !\n");			return;		}		if (!io_base) {#if DEBUG			dt_printf(dct, "no io range ->mem ");#endif						use_io = false;		}	}	if (!use_io)		if (get_logical_address(entryID, 20, (LogicalAddress *)&io_base, NULL) != noErr) {			dt_printf(dct, "can't get addresses !\n");			return;		}	if (!io_base) {		dt_printf(dct, "no io base !\n");		return;	}#if DEBUG	dt_printf(dct, "base = 0x%x \n", io_base);#endif		*(io_base + 0x14) = 0x40;	__eieio();	(void)*(io_base + 0x14);	__eieio();	dt_printf(dct, "reseted.\n");}#define OHCI_USB_RESET		(0 << 6)voidreset_apple_USB(RegEntryIDPtr entryID){	char				prop[MAX_STRING_PROP_SIZE];	UInt32				addrs_count;	volatile UInt32		*io_base;		get_string_property(entryID, "name", prop);	if (strcmp(prop, "usb"))		return;	get_string_property(entryID, "device_type", prop);	if (strcmp(prop, "usb"))		return;			dt_printf(dct, "usb: ");	addrs_count = count_assigned_addresses(entryID);	if (addrs_count < 1) {		dt_printf(dct, "not enough addresses !\n");		return;	}	if (get_logical_address(entryID, 16, (LogicalAddress *)&io_base, NULL) != noErr) {		dt_printf(dct, "can't get addresses !\n");		return;	}	if (!io_base) {		dt_printf(dct, "no io base !\n");		return;	}	#if DEBUG	dt_printf(dct, "base = 0x%x ", io_base);#endif		*(io_base + 0x02) = 0x01000000UL;	__eieio();	(volatile void)*(io_base + 0x02);	__eieio();	dt_printf(dct, "reseted.\n");}#define ATI64_BUS_MSTR_RESET		0x00000002#define ATI64_BUS_FLUSH_BUF			0x00000004#define ATI64_BUS_CNTL				0x00a0#define ATI64_GUI_ENGINE_ENABLE		0x0100#define ATI64_GEN_TEST_CNTL			0x00d0#define ATI64_BUS_HOST_ERR_ACK		0x00800000#define ATI64_BUS_FIFO_ERR_ACK		0x00200000#define ATI64_CONFIG_CHIP_ID		0x00E0#define ATI64_CFG_CHIP_TYPE			0x0000FFFF#define ATI64_CFG_CHIP_REV			0xFF000000#define ATI128_BUS_CNTL				0x0030#define ATI128_BUS_MASTER_DIS  		0x00000040#define ATI128_CONFIG_CNTL			0x00E0			#define ATI128_SOFT_RESET_GUI		0x00000001#define ATI128_GEN_RESET_CNTL		0x00f0static inline void ati_regw(unsigned long base_addr, volatile unsigned long regindex, unsigned long regdata){  	__stwbrx(regdata, (void *)base_addr, (int)regindex);	__eieio();}static inline unsigned long ati_regr(unsigned long base_addr, volatile unsigned long regindex){	unsigned long val;  	  	val = __lwbrx((void *)base_addr, (int)regindex);	__eieio();	return val;}voidreset_ATI_mach64_master(RegEntryIDPtr entryID){	char				prop[MAX_STRING_PROP_SIZE];	UInt32				addrs_count;	UInt32				base, chip_id;	OSStatus			err;		get_string_property(entryID, "name", prop);	if (strncmp(prop, "ATY,mach64", 10) && strncmp(prop, "ATY,264", 7)		&& strncmp(prop, "ATY,RagePro", 11))		return;		dt_printf(dct, "aty64: ");	err = noErr;	addrs_count = count_assigned_addresses(entryID);	switch(addrs_count) {		case 1:		case 2:		case 3:			err = get_logical_address(entryID, 0, (LogicalAddress *)&base, NULL);			break;		case 4:			err = get_logical_address(entryID, 20, (LogicalAddress *)&base, NULL);			break;		default:			dt_printf(dct, "bad address count !\n");			return;	}	if (!base || (err != noErr)) {		dt_printf(dct, "no address (err:%d) !\n", err);		return;	}			base += 0x7ffc00;	chip_id = ati_regr(base, ATI64_CONFIG_CHIP_ID);#if DEBUG	dt_printf(dct, "base = 0x%x, chip_ID: 0x%04lx, rv: 0x%x ",		base, chip_id & ATI64_CFG_CHIP_TYPE, (chip_id & ATI64_CFG_CHIP_REV) >> 24);#endif	/* reset bus master */	ati_regw(base, ATI64_BUS_CNTL, ati_regr(base, ATI64_BUS_CNTL) | ATI64_BUS_MSTR_RESET);	/* flush buffer, if bus mastering was memory <-> frame buffer */	ati_regw(base, ATI64_BUS_CNTL, ati_regr(base, ATI64_BUS_CNTL) | ATI64_BUS_FLUSH_BUF);	/* reset graphic engine and clear errors, if bus mastering */	/* was memory -> command queue or HOST_DATA */	ati_regw(base, ATI64_GEN_TEST_CNTL, ati_regr(base, ATI64_GEN_TEST_CNTL) & ~ATI64_GUI_ENGINE_ENABLE);	ati_regw(base, ATI64_GEN_TEST_CNTL, ati_regr(base, ATI64_GEN_TEST_CNTL) | ATI64_GUI_ENGINE_ENABLE);	/* No effect for at least 3D RageLTPro, but an insurance. */	ati_regw(base, ATI64_BUS_CNTL, ati_regr(base, ATI64_BUS_CNTL) | ATI64_BUS_HOST_ERR_ACK | ATI64_BUS_FIFO_ERR_ACK);	(void)ati_regr(base, ATI64_BUS_CNTL);	dt_printf(dct, "reseted.\n");}	voidreset_ATI_rage128_master(RegEntryIDPtr entryID){	UInt32				base, gen_reset_cntl;	UInt32				id, sz;	OSStatus			err;		sz = 4;	err = get_one_property(entryID, "vendor-id", &id, &sz);	if (err != noErr)		return;	if (id != 0x1002)		return;	sz = 4;	err = get_one_property(entryID, "device-id", &id, &sz);	if (err != noErr)		return;	if ((id != 0x5245)&&(id != 0x5246)&&(id != 0x524B)&&(id != 0x524C))		return;			dt_printf(dct, "aty128: ");	err = get_logical_address(entryID, 24, (LogicalAddress *)&base, NULL);	if (err != noErr) {		dt_printf(dct, "no address (err:%d) !\n", err);		return;	}		#if DEBUG	dt_printf(dct, "base = 0x%x, rev: 0x%x ",		base, (ati_regr(base, ATI128_CONFIG_CNTL) >> 16) & 0x1F);#endif	/* reset bus master */#if DEBUG	dt_printf(dct, "bm: %d ", (ati_regr(base, ATI128_BUS_CNTL) & ATI128_BUS_MASTER_DIS) != 0);#endif    ati_regw(base, ATI128_BUS_CNTL, ati_regr(base, ATI128_BUS_CNTL) | ATI128_BUS_MASTER_DIS);    (void)ati_regr(base, ATI128_BUS_CNTL);	/* reset GUI */    gen_reset_cntl = ati_regr(base, ATI128_GEN_RESET_CNTL);    ati_regw(base, ATI128_GEN_RESET_CNTL, gen_reset_cntl | ATI128_SOFT_RESET_GUI);    (void)ati_regr(base, ATI128_GEN_RESET_CNTL);    ati_regw(base, ATI128_GEN_RESET_CNTL, gen_reset_cntl & ~(ATI128_SOFT_RESET_GUI));    (void)ati_regr(base, ATI128_GEN_RESET_CNTL);		dt_printf(dct, "reseted.\n");}	static OSStatusiterate_devices(iterate_device_proc	proc){	RegEntryIter			iterator;	RegEntryIterationOp		operation;	unsigned long			address = 0;	OSStatus				err;	Boolean					done;		// Create an Iterator	operation = kRegIterRoot;		err = RegistryEntryIterateCreate(&iterator);		if (err == noErr) {		RegEntryID			entryID;		RegistryEntryIDInit(&entryID);		do {			done = false;			err = RegistryEntryIterate(	&iterator,										operation,										&entryID,										&done);			if (operation == kRegIterRoot)				operation = kRegIterDescendants;			else if (operation == kRegIterDescendants)				operation = kRegIterContinue;			if (!done && (err == noErr))				proc(&entryID);		} while (!done && (err == noErr));		RegistryEntryIDDispose(&entryID);	}	if (err != noErr)		dt_printf(dct, "iterate failed with error %d\n", err);	RegistryEntryIterateDispose(&iterator);		return err;}static OSStatusfind_child_device(RegEntryIDPtr parent, RegEntryIDPtr result){	RegEntryIter			iterator;	RegEntryIterationOp		operation;	unsigned long			address = 0;	OSStatus				err;	Boolean					done;		// Create an Iterator	err = RegistryEntryIterateCreate(&iterator);	if (err != noErr)		return err;			RegistryEntryIterateSet(&iterator, parent);	operation = kRegIterChildren;	if (err == noErr) {		done = false;		err = RegistryEntryIterate(	&iterator,									operation,									result,									&done);		if (done)			err = -1;	}	if (err != noErr)		dt_printf(dct, "iterate failed with error %d\n", err);	RegistryEntryIterateDispose(&iterator);		return err;}