#include <Types.h>#include <Memory.h>#include <Quickdraw.h>#include <Palettes.h>#include <Fonts.h>#include <Events.h>#include <Menus.h>#include <Errors.h>#include <Files.h>#include <Devices.h>#include <Windows.h>#include <Icons.h>#include <LowMem.h>#include <a4Stuff.h>#include "debug_text.h"#include "nr_wrapper.h"#define VERSION		"1.0a3"static void set_a5_world(void);static void test_paint(void);static void setup_debug_context(Boolean debug_visible);static void show_context(void);static void	setup_quickdraw(void);static void	close_quickdraw(void);static void draw_penguin(short whichPenguin);static void	load_boot4(void);static void	check_opt_keys(void);/* Globals */dt_context*	dct;QDGlobals	qd;GrafPtr		port;dt_context	g_dct;CGrafPort	g_grafport;Boolean		g_use_color = 1;Boolean		g_debug_visible = 0;Boolean		g_no_video = 0;#define kPenguinNormalID		128#define kPenguinRamDiskID		129#define kPenguinErrorID			130void main(void){	EnterCodeResource();		check_opt_keys();	setup_debug_context(g_debug_visible);		dt_printf(dct, "Welcome to miBoot v" VERSION "\n\n");		show_context();		dt_printf(dct, "Setting up drawing environment...");	setup_quickdraw();	dt_printf(dct, "ok.\n");	dt_printf(dct, "Drawing penguin...");	draw_penguin(kPenguinNormalID);	dt_printf(dct, "ok.\n");	load_boot4();		draw_penguin(kPenguinErrorID);	dt_printf(dct, "\nQuitting...\n");		close_quickdraw();		ExitCodeResource();}voidload_boot4(void){	Handle	rsrc = GetResource('boot', 4);	if (!rsrc) {		dt_printf(dct, "GetResource('boot', 4) error %d\n", ResError());		return;	}	DetachResource(rsrc);	MoveHHi(rsrc);	HLock(rsrc);		((void (*)(dt_context*, Boolean))(*rsrc))(dct, g_no_video);		DisposeHandle(rsrc);}voiddraw_penguin(short whichPenguin){	CIconHandle	icon;	Rect		bounds;		icon = GetCIcon(whichPenguin);	if (!icon) {		dt_printf(dct, "Can't load penguin icon (ResErr: %d) !\n",			ResError());		return;	}	bounds.left = port->portRect.left + (port->portRect.right - port->portRect.left)/2 - 16;	bounds.top = port->portRect.top + (port->portRect.bottom - port->portRect.top)/2 - 16;	bounds.right = bounds.left + 32;	bounds.bottom = bounds.top + 32;		FillRect(&bounds, &qd.gray);	PlotCIcon(&bounds, icon);	DisposeCIcon(icon);}asm voidset_a5_world(void){#define kLM_CurrentA5	0x904	lea		qd, a0	adda.l	#struct(QDGlobals.thePort), a0	move.l	a5, kLM_CurrentA5	rts}voidsetup_quickdraw(void){	set_a5_world();	InitGraf(&qd.thePort);	InitPalettes();	port = (GrafPtr)&g_grafport;	if (g_use_color)		OpenCPort(&g_grafport);	else		OpenPort(port);	SetPort(port);	PenNormal();}voidclose_quickdraw(void){	if (g_use_color)		CloseCPort(&g_grafport);	else		ClosePort(port);}voidsetup_debug_context(Boolean debug_visible){	GDHandle	hdl;	PixMapPtr	pm;		hdl = LMGetMainDevice();	if (hdl == NULL || (**hdl).gdPMap == NULL)		return;	pm = *(**hdl).gdPMap;	if (pm->baseAddr == NULL)		return;		dct = &g_dct;		dct->base = (unsigned char *)pm->baseAddr;	dct->row_bytes = pm->rowBytes & 0x3fff;	dct->width = pm->bounds.right - pm->bounds.left;	dct->height = pm->bounds.bottom - pm->bounds.top;	dct->depth = pm->pixelSize;	dct->visible = debug_visible;		if (dct->depth == 15)		dct->depth = 16;		dct->base += pm->bounds.top * dct->row_bytes;	dct->base += pm->bounds.left * (dct->depth >> 3);		dt_init(dct);}asm UInt32 read_sp(void){	move.l	sp, d0	rts}voidshow_context(void){	dt_printf(dct, "SystemZone start : 0x%08lx\n", LMGetSysZone()->bkLim);	dt_printf(dct, "SystemZone free  : 0x%08lx\n", LMGetSysZone()->zcbFree);	dt_printf(dct, "CurrenZone start : 0x%08lx\n", LMGetTheZone()->bkLim);	dt_printf(dct, "CurrenZone free  : 0x%08lx\n", LMGetTheZone()->zcbFree);	dt_printf(dct, "ApplZone start   : 0x%08lx\n", LMGetApplZone()->bkLim);	dt_printf(dct, "ApplZone free    : 0x%08lx\n", LMGetApplZone()->zcbFree);	dt_printf(dct, "ApplLimit        : 0x%08lx\n", LMGetApplLimit());	dt_printf(dct, "CurStackBase     : 0x%08lx\n", LMGetCurStackBase());	dt_printf(dct, "BufPtr           : 0x%08lx\n", LMGetBufPtr());	dt_printf(dct, "MemTop           : 0x%08lx\n", LMGetMemTop());	dt_printf(dct, "-> limit         : 0x%08lx\n", ((UInt32)LMGetMemTop()/2 + 1024));	dt_printf(dct, "sp               : 0x%08lx\n", read_sp());	dt_printf(dct, "-> free          : 0x%08lx\n", read_sp() - (UInt32)LMGetApplLimit());}static check_one_key(KeyMap map, UInt8 key_code){	return ((((UInt8 *)map)[key_code >> 3] >> (key_code & 7)) & 1);}voidcheck_opt_keys(void){	KeyMap	keys;		GetKeys(keys);	if (check_one_key(keys, 0x3a)) // option		g_debug_visible = 1;	if (check_one_key(keys, 0x38)) // shift		g_no_video = 1;}