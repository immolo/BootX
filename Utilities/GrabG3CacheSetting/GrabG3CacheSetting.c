/* * GrabG3CacheSettings * * Tool for capturing L2CR value of G3 processors. * * Written by BenH with code from Terry Greeniaus (thanks Terry) * * This software is distributed under the GNU Public Licence * (see the file COPYING for more details). * */#include <stdio.h>#include <stdlib.h>#include <time.h>#include <string.h>#include <Memory.h>#include <Devices.h>#include <Gestalt.h>#include <Resources.h>#include <Folders.h>#include <Errors.h>#define FUNC_ADDR(x) ((unsigned long*)x)[0]typedef struct MyInterruptPatchData{	unsigned long	originalVector;	unsigned long	r4;	unsigned long	cr;	unsigned long	code[];}MyInterruptPatchData;OSErr LocateBootXPrefsFile(FSSpec *outSpec);void InstallInterruptPatch(void);void RemoveInterruptPatch(void);UInt32 MySCInstruction(void);Ptr GetPhysicalAddress(void* ptr);void InterruptPatchCode(void);void InterruptPatchCodeEnd(void);MyInterruptPatchData*	gDatas;#define PRG1	273#define PRG2	274#define L2CR	1017#define MSR_PR	17int main(void){	long cpuFamily;	UInt32 l2cr;	OSErr err;	FSSpec spec;	short prefFileRef;	Handle rsrc;		printf("Querying CPU family...\n");	err = Gestalt(gestaltNativeCPUfamily, &cpuFamily);	if (err != noErr)	{		printf("Error %d in Gestalt()\n");		exit(0);	}	if (cpuFamily != gestaltCPU750)	{		printf("Error, CPU is not a G3\n");		exit(0);	}	printf ("Getting value of G3 L2CR register ...\n");	gDatas = NULL;	InstallInterruptPatch();	l2cr = MySCInstruction();	RemoveInterruptPatch();	printf("L2CR value is: 0x%08lx, saving...\n", l2cr);	err = LocateBootXPrefsFile(&spec);		if (err != noErr)	{		printf("Error %d, Can't find BootX preferences file\n", err);		exit(0);	}		prefFileRef = FSpOpenResFile(&spec, fsWrPerm);	if (prefFileRef == -1)	{		err = ResError();		if (err == noErr) err = -1;		printf("Error %d, could not open BootX prefs file\n", err);		exit(0);	}	UseResFile(prefFileRef);	rsrc = Get1Resource('L2CR', 0);	if (rsrc)	{		RemoveResource(rsrc);		DisposeHandle(rsrc);	}	rsrc = NewHandle(4);	*((UInt32 *)(*rsrc)) = l2cr;	AddResource(rsrc, 'L2CR', 0, "\p");	WriteResource(rsrc);	CloseResFile(prefFileRef);		printf("Done.\n\nThe \"Set G3 Cache\" option in BootX should now be available.\n");		return 0;}OSErrLocateBootXPrefsFile(FSSpec *outSpec){	CInfoPBRec	pb;	OSErr err;	int i;	err = FindFolder(	kOnSystemDisk,						kPreferencesFolderType,						false,						&outSpec->vRefNum,						&outSpec->parID);	if (err != noErr)		return err;		i=0;	do	{		memset(&pb, 0, sizeof(CInfoPBRec));		pb.hFileInfo.ioNamePtr = outSpec->name;		pb.hFileInfo.ioVRefNum = outSpec->vRefNum;		pb.hFileInfo.ioDirID = outSpec->parID;		pb.hFileInfo.ioFDirIndex = ++i;		err = PBGetCatInfoSync(&pb);		if ((err == noErr) && ((pb.hFileInfo.ioFlAttrib & ioDirMask) == 0)			&& (pb.hFileInfo.ioFlFndrInfo.fdCreator == 'BooX')			&& (pb.hFileInfo.ioFlFndrInfo.fdType == 'pref'))			return noErr;	} while(err == noErr);		return fnfErr;}void InstallInterruptPatch(void){	void*					myPatchPhys;	unsigned long			codeLen;	MyInterruptPatchData*	myPatch;		codeLen =  FUNC_ADDR(InterruptPatchCodeEnd) - FUNC_ADDR(InterruptPatchCode);	myPatch =  (MyInterruptPatchData*)NewPtrSys(sizeof(MyInterruptPatchData) + codeLen);	myPatch->originalVector			= *(unsigned long*)0x5FFFE450;	gDatas = myPatch;			BlockMove((void *)FUNC_ADDR(InterruptPatchCode),myPatch->code,codeLen);	LockMemoryContiguous(myPatch,sizeof(MyInterruptPatchData) + codeLen);	MakeDataExecutable(myPatch->code,codeLen);	myPatchPhys = GetPhysicalAddress(myPatch->code);	*(unsigned long*)0x5FFFE450 = (unsigned long)myPatchPhys;}PtrGetPhysicalAddress(void* ptr){	LogicalToPhysicalTable	table;	unsigned long			count;	OSErr					err;		table.logical.address	= ptr;	table.logical.count		= 1024;	count = sizeof( table ) / sizeof( MemoryBlock ) - 1;		err = GetPhysical( &table, &count );	if ( err != noErr)		return ptr;		return ( Ptr ) ( table.physical[0].address );}void RemoveInterruptPatch(void){	*(unsigned long*)0x5FFFE450 = gDatas->originalVector;}asm UInt32 MySCInstruction(void){	lis	r3,'Bo';	ori	r3,r3,'oX';	sc;	mr r3, r4	blr;}asm void InterruptPatchCode(void){	// Get our data area	subi	sp,sp,sizeof(MyInterruptPatchData);		// Save some registers	stw	r4,MyInterruptPatchData.r4(sp);	mfcr	r4;	stw	r4,MyInterruptPatchData.cr(sp);		// Test the r3 key	lis	r4,'Bo';	ori	r4,r4,'oX';	cmpw	r3,r4;	bne	@callOriginalVector;	// OK, it's for us!  Fix everything up and go home.  We don't need	// to fix r4, since that's a volatile register the way we	// are accessed.  Also turn off MSR[PR] bit.	lwz	r4,MyInterruptPatchData.cr(sp);	mtcrf	0xFF,r4;	mfspr   r4,PRG2;	mtlr	r4;	mfspr 	sp, PRG1;	mfsrr1	r4;	rlwinm	r4,r4,0,MSR_PR+1,MSR_PR-1;	// MSR_PR == MSR[PR] bit number	mfspr	r4,L2CR	rfi;@callOriginalVector:	// OK, we need to call the original vector, since it wasn't for us.	// Restore the cr and r4, and set up sp the way it would have been	// set up for us (i.e. sp contains the address of the original vector	// code and we move it to lr and do a blrl like ROM does).	lwz	r4,MyInterruptPatchData.cr(sp);	mtcrf	0xFF,r4;	lwz	r4,MyInterruptPatchData.r4(sp);	lwz	sp,MyInterruptPatchData.originalVector(sp);	mtlr	sp;	blrl;entry InterruptPatchCodeEndInterruptPatchCodeEnd:	}