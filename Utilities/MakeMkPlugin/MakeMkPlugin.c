#include <Files.h>#include <Resources.h>#include <Folders.h>#include <StandardFile.h>#include <stdio.h>void		main(void);Boolean		filter(CInfoPBPtr pb);voidmain(void){	OSErr	err;	short	vRefNum;	long	parID;	FSSpec	sourceSpec;	FSSpec	destSpec;	FInfo	destInfo;	short	resfile;	Handle	rsrc;	Ptr		p;	Str255	newName = "\pMkLinux BootX Plugin";	UInt32	size;		printf("MakeMkPlugin 0.1\n\n");	printf("Searching MkLinux booter in Extensions folder....\n");	err = FindFolder(	kOnSystemDisk,						kExtensionFolderType,						false,						&vRefNum,						&parID);	if (err != noErr)	{		printf("Could not find Extensions folder, err: %d\n", (int)err);		return;	}		err = FSMakeFSSpec(vRefNum, parID, "\pMkLinux Booter", &sourceSpec);	if (err != noErr)	{		FileFilterUPP		filterUPP;		StandardFileReply	SFR;		SFTypeList			sfTypes;		unsigned long		toto;		int					i;				printf("Can't find MkLinux Booter, please locate it");		fflush(stdout);		for (i=0; i<10; i++)		{			printf(".");			fflush(stdout);			Delay(15, &toto);		}		printf("\n");		filterUPP = NewFileFilterProc(filter);		StandardGetFile(filterUPP, -1, sfTypes, &SFR);		DisposeRoutineDescriptor(filterUPP);		if (!SFR.sfGood)			return;		sourceSpec = SFR.sfFile;	}		err = FSMakeFSSpec(vRefNum, parID, newName, &destSpec);	if (err == noErr)		FSpDelete(&destSpec);	else if (err != fnfErr)	{		printf("Error %d locating destination\n", (int)err);		return;	}	printf("Building \"%#s\" ...\n", newName);	err = FileCopy(	sourceSpec.vRefNum,					sourceSpec.parID,					sourceSpec.name,					destSpec.vRefNum,					destSpec.parID,					NULL,					destSpec.name,					NULL, 0,					true);	if (err != noErr)	{		printf("Error %d when copying file\n", (int)err);		return;	}		printf("Changing type/creator...\n");		err = FSpGetFInfo(&destSpec, &destInfo);	if (err == noErr)	{		destInfo.fdCreator	= 'BooI';		destInfo.fdType		= 'Mkli';		err = FSpSetFInfo(&destSpec, &destInfo);	}	if (err != noErr)	{		printf("Error %d when making plugin\n", (int)err);		goto bail_delete;	}		printf("Patching...\n");	resfile = FSpOpenResFile(&destSpec, fsWrPerm);	if (resfile == -1)	{		err = ResError();		printf("Error %d when opening destination file\n", (int)err);		goto bail_delete;	}		rsrc = Get1Resource('vers', 1);	if (rsrc == NULL)	{		err = ResError();		printf("Error %d when getting vers 1 resource\n", (int)err);		goto bail_close;	}		if (**((UInt32 **)rsrc) != 0x01408000)	{		printf("Cannot patch this version of MkLinux Booter, please use 1.4 !\n");		goto bail_close;	}		ReleaseResource(rsrc);		rsrc = Get1Resource('INIT', 0);	if (rsrc == NULL)	{		err = ResError();		printf("Error %d when getting INIT 0 resource\n", (int)err);		goto bail_close;	}		size = GetHandleSize(rsrc);	SetHandleSize(rsrc, size+newName[0]+1);	BlockMoveData(newName, (*rsrc)+size, newName[0]+1);		HLock(rsrc);	p = *rsrc;		p += 0x1EDA;	if (*((UInt32 *)p) != 0x41FA0696)	{		err = ResError();		printf("Couldn't find expected datas in INIT resource\n");		goto bail_close;	}		p+=2;	*((UInt16 *)p) = size - 0x1EDA - 2;		ChangedResource(rsrc);	WriteResource(rsrc);		CloseResFile(resfile);	FlushVol(NULL, destSpec.vRefNum);	printf("Done.\n");		return;bail_close:		CloseResFile(resfile);bail_delete:	FSpDelete(&destSpec);		printf("Failed.\n");}Booleanfilter(CInfoPBPtr pb){	if (pb->hFileInfo.ioFlAttrib & ioDirMask)		return true;		return (pb->hFileInfo.ioFlFndrInfo.fdType != 'scri' ||			pb->hFileInfo.ioFlFndrInfo.fdCreator != 'MkLB');}